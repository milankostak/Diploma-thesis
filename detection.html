<!DOCTYPE html>
<html lang="en-GB" dir="ltr">
<head>
<meta charset="UTF-8">
<!--<meta name="viewport" content="width=device-width,initial-scale=1">-->
<title>Detection</title>
<link rel="stylesheet" type="text/css" href="/css/detection.css">
<script type="text/javascript" src="/js/transforms3d.js"></script>
<script type="text/javascript" src="/js/webgl-utils.js"></script>
<script type="text/javascript" src="/js/rotation.js"></script>
<script id="shader-fs1" type="x-shader/x-fragment">
	precision mediump float;

	uniform sampler2D texture;
	uniform float width;
	uniform float height;

	varying vec2 textureCoord;

	void main(void) {
		// current coordinates
		float x = floor(textureCoord.x * width);
		float y = floor(textureCoord.y * height);

		// base top left coordinates of given square
		float baseX = x - mod(x, 4.0);
		float baseY = y - mod(y, 4.0);

		// distance between 2 pixels
		vec2 diff = vec2(1.0/width, 1.0/height);

		// actual texture coordinates of top left pixel
		// + diff/2 because textureCoord is always between numbers
		vec2 baseTextureCoord = vec2(baseX / width + diff.x / 2.0, baseY / height + diff.y / 2.0);

		// get all 16 pixels in given square
		// done this way because when making the texture smaller, browsers where returning different sampled coordinates
		// doing it like this means all 16 pixels have the same values and it doesn't matter anymore which one is picked by browser
		vec4 pix00 = texture2D(texture, vec2(baseTextureCoord.x, baseTextureCoord.y));
		vec4 pix10 = texture2D(texture, vec2(baseTextureCoord.x + diff.x, baseTextureCoord.y));
		vec4 pix20 = texture2D(texture, vec2(baseTextureCoord.x + 2.0*diff.x, baseTextureCoord.y));
		vec4 pix30 = texture2D(texture, vec2(baseTextureCoord.x + 3.0*diff.x, baseTextureCoord.y));

		vec4 pix01 = texture2D(texture, vec2(baseTextureCoord.x, baseTextureCoord.y + diff.y));
		vec4 pix11 = texture2D(texture, vec2(baseTextureCoord.x + diff.x, baseTextureCoord.y + diff.y));
		vec4 pix21 = texture2D(texture, vec2(baseTextureCoord.x + 2.0*diff.x, baseTextureCoord.y + diff.y));
		vec4 pix31 = texture2D(texture, vec2(baseTextureCoord.x + 3.0*diff.x, baseTextureCoord.y + diff.y));

		vec4 pix02 = texture2D(texture, vec2(baseTextureCoord.x, baseTextureCoord.y + 2.0*diff.y));
		vec4 pix12 = texture2D(texture, vec2(baseTextureCoord.x + diff.x, baseTextureCoord.y + 2.0*diff.y));
		vec4 pix22 = texture2D(texture, vec2(baseTextureCoord.x + 2.0*diff.x, baseTextureCoord.y + 2.0*diff.y));
		vec4 pix32 = texture2D(texture, vec2(baseTextureCoord.x + 3.0*diff.x, baseTextureCoord.y + 2.0*diff.y));

		vec4 pix03 = texture2D(texture, vec2(baseTextureCoord.x, baseTextureCoord.y + 3.0*diff.y));
		vec4 pix13 = texture2D(texture, vec2(baseTextureCoord.x + diff.x, baseTextureCoord.y + 3.0*diff.y));
		vec4 pix23 = texture2D(texture, vec2(baseTextureCoord.x + 2.0*diff.x, baseTextureCoord.y + 3.0*diff.y));
		vec4 pix33 = texture2D(texture, vec2(baseTextureCoord.x + 3.0*diff.x, baseTextureCoord.y + 3.0*diff.y));

		float thresholdG = 0.6;
		float thresholdRB = 0.4;
		float count = 0.0;

		// count it as pixel of interest only if green is high enough and if red,blue not too much
		if (pix00.g > thresholdG && pix00.r < thresholdRB && pix00.b < thresholdRB) count += 1.0;
		if (pix10.g > thresholdG && pix10.r < thresholdRB && pix10.b < thresholdRB) count += 1.0;
		if (pix20.g > thresholdG && pix20.r < thresholdRB && pix20.b < thresholdRB) count += 1.0;
		if (pix30.g > thresholdG && pix30.r < thresholdRB && pix30.b < thresholdRB) count += 1.0;

		if (pix01.g > thresholdG && pix01.r < thresholdRB && pix01.b < thresholdRB) count += 1.0;
		if (pix11.g > thresholdG && pix11.r < thresholdRB && pix11.b < thresholdRB) count += 1.0;
		if (pix21.g > thresholdG && pix21.r < thresholdRB && pix21.b < thresholdRB) count += 1.0;
		if (pix31.g > thresholdG && pix31.r < thresholdRB && pix31.b < thresholdRB) count += 1.0;

		if (pix02.g > thresholdG && pix02.r < thresholdRB && pix02.b < thresholdRB) count += 1.0;
		if (pix12.g > thresholdG && pix12.r < thresholdRB && pix12.b < thresholdRB) count += 1.0;
		if (pix22.g > thresholdG && pix22.r < thresholdRB && pix22.b < thresholdRB) count += 1.0;
		if (pix32.g > thresholdG && pix32.r < thresholdRB && pix32.b < thresholdRB) count += 1.0;

		if (pix03.g > thresholdG && pix03.r < thresholdRB && pix03.b < thresholdRB) count += 1.0;
		if (pix13.g > thresholdG && pix13.r < thresholdRB && pix13.b < thresholdRB) count += 1.0;
		if (pix23.g > thresholdG && pix23.r < thresholdRB && pix23.b < thresholdRB) count += 1.0;
		if (pix33.g > thresholdG && pix33.r < thresholdRB && pix33.b < thresholdRB) count += 1.0;

		// write count, and top left coordinates
		gl_FragColor = vec4(count, baseX, baseY, 1.0);
	}
</script>
<script id="shader-fs2" type="x-shader/x-fragment">
	precision mediump float;

	uniform sampler2D texture;
	uniform float width;//w4
	uniform float height;//h4

	varying vec2 textureCoord;

	void main(void) {
		// current coordinates
		float x = floor(textureCoord.x * width);
		float y = floor(textureCoord.y * height);

		// base top left synthetic coordinates of given square
		// now working with smaller picture already so real coordinates are saved inside pixels
		float baseX = x - mod(x, 3.0);
		float baseY = y - mod(y, 3.0);

		// distance between 2 pixels
		vec2 diff = vec2(1.0/width, 1.0/height);

		// actual texture coordinates of top left pixel
		// + diff/2 because textureCoord is always between numbers
		vec2 baseTextureCoord = vec2(baseX / width + diff.x / 2.0, baseY / height + diff.y / 2.0);

		vec4 pix00 = texture2D(texture, vec2(baseTextureCoord.x, baseTextureCoord.y));
		vec4 pix10 = texture2D(texture, vec2(baseTextureCoord.x + diff.x, baseTextureCoord.y));
		vec4 pix20 = texture2D(texture, vec2(baseTextureCoord.x + 2.0*diff.x, baseTextureCoord.y));

		vec4 pix01 = texture2D(texture, vec2(baseTextureCoord.x, baseTextureCoord.y + diff.y));
		vec4 pix11 = texture2D(texture, vec2(baseTextureCoord.x + diff.x, baseTextureCoord.y + diff.y));
		vec4 pix21 = texture2D(texture, vec2(baseTextureCoord.x + 2.0*diff.x, baseTextureCoord.y + diff.y));

		vec4 pix02 = texture2D(texture, vec2(baseTextureCoord.x, baseTextureCoord.y + 2.0*diff.y));
		vec4 pix12 = texture2D(texture, vec2(baseTextureCoord.x + diff.x, baseTextureCoord.y + 2.0*diff.y));
		vec4 pix22 = texture2D(texture, vec2(baseTextureCoord.x + 2.0*diff.x, baseTextureCoord.y + 2.0*diff.y));

		float sumCount = pix00.r + pix10.r + pix20.r + pix01.r + pix11.r + pix21.r + pix02.r + pix12.r + pix22.r;

		// no interesting pixels here
		// discard squares with one interesting pixel?
		if (sumCount < 2.0) discard;

		// weighted arithmetic mean of coordinates
		float sumX =
			pix00.r * pix00.g + pix10.r * pix10.g + pix20.r * pix20.g +
			pix01.r * pix01.g + pix11.r * pix11.g + pix21.r * pix21.g +
			pix02.r * pix02.g + pix12.r * pix12.g + pix22.r * pix22.g;
		float meanX = sumX / sumCount;
		float sumY =
			pix00.r * pix00.b + pix10.r * pix10.b + pix20.r * pix20.b +
			pix01.r * pix01.b + pix11.r * pix11.b + pix21.r * pix21.b +
			pix02.r * pix02.b + pix12.r * pix12.b + pix22.r * pix22.b;
		float meanY = sumY / sumCount;


		gl_FragColor = vec4(sumCount, meanX, meanY, 1.0);
	}
</script>
<script id="shader-fs-draw" type="x-shader/x-fragment">
	precision mediump float;

	uniform sampler2D texture;

	varying vec2 textureCoord;

	void main(void) {
		gl_FragColor = texture2D(texture, textureCoord);
	}
</script>
<script id="shader-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec2 aTextureCoord;

	uniform mat4 rotation;

	varying vec2 textureCoord;

	void main(void) {
		textureCoord = aTextureCoord;
		gl_Position = rotation * vec4(aVertexPosition, 1.0);
	}
</script>
<script type="text/javascript">
	"use strict";

	// HTMLCanvasElement
	var canvas;
	// WebGLRenderingContext
	var gl;
	// WebGLProgram
	var program1, program2, programDraw;
	// WebGLBuffer
	var vertexBuffer, indexBuffer, textureBuffer;
	// WebGLTexture
	var cameraTexture, texture1, texture2;
	// WebGLFramebuffer
	var fbo;
	// precision of reading from texture, either FLOAT or HALF_FLOAT_OES
	var texturePrecision;
	// numbers, input width and height
	var width, height, w4, h4, w12, h12;
	// Float32Array
	var readBuffer;
	// HTMLVideoElement
	var video;
	// variables for sending marker location
	var dataToSend = [], positionSequence = 0;

	var DO_NOTHING = 1, DO_POSITION = 2, DO_ROTATION = 3;

	var currentMethod = DO_NOTHING;

	var sendPositionInterval;


	function initBuffers() {
		let scene = new Utils.Scene();
		scene.add(new Utils.Face(1, 1, 0, 0, 0, {strip: false}));

		vertexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(scene.vertices), gl.STATIC_DRAW);
		vertexBuffer.itemSize = 3;
		vertexBuffer.numItems = scene.vertices.length;

		indexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(scene.indices), gl.STATIC_DRAW);
		indexBuffer.itemSize = 1;
		indexBuffer.numItems = scene.indices.length;

		textureBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(scene.textureCoords), gl.STATIC_DRAW);
		textureBuffer.itemSize = 2;
		textureBuffer.numItems = scene.textureCoords.length;
	}

	var times = [];
	var count = 0;
	function repaint() {

		// bind vertex data
		gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
		gl.vertexAttribPointer(program1.vertexPositionAttribute, vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
		gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
		gl.vertexAttribPointer(program1.vertexTexCoordAttribute, textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

		// bind framebuffer
		gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

//**********************************************************
		gl.useProgram(program1);

		gl.uniformMatrix4fv(program1.rotation, false, Utils.convert(new Mat4Identity()));
		gl.uniform1f(program1.width, width);
		gl.uniform1f(program1.height, height);

		gl.bindTexture(gl.TEXTURE_2D, texture2);
		// target, level, internalformat, width, height, border, format, type, ArrayBufferView? pixels)
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w4, h4, 0, gl.RGBA, texturePrecision, null);
		gl.viewport(0, 0, w4, h4);

		// ... and draw to it
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture2, 0);

		// bind input texture
		gl.bindTexture(gl.TEXTURE_2D, cameraTexture);

		// draw
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		gl.drawElements(gl.TRIANGLES, indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

//**********************************************************
		gl.useProgram(program2);

		gl.uniformMatrix4fv(program2.rotation, false, Utils.convert(new Mat4RotX(Math.PI)));
		gl.uniform1f(program2.width, w4);
		gl.uniform1f(program2.height, h4);

		gl.bindTexture(gl.TEXTURE_2D, texture1);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w12, h12, 0, gl.RGBA, texturePrecision, null);
		gl.viewport(0, 0, w12, h12);

		// ... and draw to it
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture1, 0);

		// bind input texture
		gl.bindTexture(gl.TEXTURE_2D, texture2);

		// draw
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		gl.drawElements(gl.TRIANGLES, indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

//**********************************************************
		// read pixels
		//if (count++ < 100) {
			//let time = new Date().getTime();
			gl.readPixels(0, 0, w12, h12, gl.RGBA, gl.FLOAT, readBuffer);
			/*times.push(new Date().getTime() - time);
			if (times.length % 60 == 0) {
				let sum = 0;
				for (var i = 0; i < times.length; i++) {
					sum += times[i];
				}
				console.log(sum / times.length);
				times.length = 0;
			}

			for (let i = 0; i < readBuffer.length; i+=4) {
				if (readBuffer[i] >= 1) {
					console.log(readBuffer[i], readBuffer[i+1], readBuffer[i+2], readBuffer[i+3]);
				}
			}*/

			let max = 0, x, y;
			for (let i = 0; i < readBuffer.length; i+=4) {
				if (readBuffer[i] >= max) {
					max = readBuffer[i];
					x = readBuffer[i+1];
					y = readBuffer[i+2];
				}
			}
			if (max > 1) {
				dataToSend.push(max, x, y);
			}
			//console.log("MAX")
			//console.log(max, x, y);
		//}

//**********************************************************
		// draw the output into canvas
		gl.useProgram(programDraw);
		gl.uniformMatrix4fv(programDraw.rotation, false, Utils.convert(new Mat4RotX(Math.PI)));
		gl.bindTexture(gl.TEXTURE_2D, texture1);
		gl.viewport(0, 0, width, height);
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		gl.drawElements(gl.TRIANGLES, indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
	}

	window.onload = function() {
		canvas = document.querySelector("canvas");
		gl = Utils.initWebGL(canvas);

		gl.clearColor(0.1, 0.1, 0.1, 1);
		gl.clearDepth(1.0);
		gl.enable(gl.DEPTH_TEST);
		gl.depthFunc(gl.LEQUAL);

		let floatExtension = gl.getExtension("OES_texture_float");
		if (!floatExtension) {
			floatExtension = gl.getExtension('OES_texture_half_float');
			texturePrecision = floatExtension.HALF_FLOAT_OES;
			console.log("Using OES_texture_half_float");
			//alert("Using OES_texture_half_float");
		} else {
			texturePrecision = gl.FLOAT;
			console.log("Using OES_texture_float");
			//alert("Using OES_texture_float");
		}

		// first step program - find points of interest and group them, using 4×4 areas
		program1 = gl.createProgram();
		Utils.initShaders(gl, program1, "shader-vs", "shader-fs1");
		gl.linkProgram(program1);
		gl.useProgram(program1);

		program1.vertexPositionAttribute = gl.getAttribLocation(program1, "aVertexPosition");
		gl.enableVertexAttribArray(program1.vertexPositionAttribute);

		program1.vertexTexCoordAttribute = gl.getAttribLocation(program1, "aTextureCoord");
		gl.enableVertexAttribArray(program1.vertexTexCoordAttribute);

		program1.rotation = gl.getUniformLocation(program1, "rotation");
		program1.texture = gl.getUniformLocation(program1, "texture");
		program1.width = gl.getUniformLocation(program1, "width");
		program1.height = gl.getUniformLocation(program1, "height");

		// second step program - further merging points of interest with weighted arithmetic mean
		program2 = gl.createProgram();
		Utils.initShaders(gl, program2, "shader-vs", "shader-fs2");
		gl.linkProgram(program2);
		gl.useProgram(program2);

		program2.vertexPositionAttribute = gl.getAttribLocation(program2, "aVertexPosition");
		gl.enableVertexAttribArray(program2.vertexPositionAttribute);

		program2.vertexTexCoordAttribute = gl.getAttribLocation(program2, "aTextureCoord");
		gl.enableVertexAttribArray(program2.vertexTexCoordAttribute);

		program2.rotation = gl.getUniformLocation(program2, "rotation");
		program2.texture = gl.getUniformLocation(program2, "texture");
		program2.width = gl.getUniformLocation(program2, "width");
		program2.height = gl.getUniformLocation(program2, "height");

		// basic draw program, doesn't do anything special in shaders
		programDraw = gl.createProgram();
		Utils.initShaders(gl, programDraw, "shader-vs", "shader-fs-draw");
		gl.linkProgram(programDraw);
		gl.useProgram(programDraw);

		programDraw.vertexPositionAttribute = gl.getAttribLocation(programDraw, "aVertexPosition");
		gl.enableVertexAttribArray(programDraw.vertexPositionAttribute);

		programDraw.vertexTexCoordAttribute = gl.getAttribLocation(programDraw, "aTextureCoord");
		gl.enableVertexAttribArray(programDraw.vertexTexCoordAttribute);

		programDraw.rotation = gl.getUniformLocation(programDraw, "rotation");
		programDraw.texture = gl.getUniformLocation(programDraw, "texture");

		// prepare frame buffer and textures
		fbo = gl.createFramebuffer();
		texture1 = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture1);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		texture2 = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture2);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

		// prepare data for drawing (basic face)
		initBuffers();

		// init requestAnimFrame function
		Utils.initRequestAnimationFrame();

		// set video listener, important for starting animation
		video = document.querySelector("video");
		video.addEventListener("canplaythrough", setupAfterGettingVideoStream, false);

		// method change listeners
		document.querySelector("label#nothing").addEventListener("click", doNothing, false);
		document.querySelector("label#position").addEventListener("click", doPosition, false);
		document.querySelector("label#rotation").addEventListener("click", doRotation, false);

		// window size listener for changing layout
		// checks which one of height or width is bigger and changes the layout appropriately
		window.addEventListener('resize', windowSizeChanged, false);
		windowSizeChanged();

		// init Rotation object with address on which server is listening
		Rotation.init("/ajax/rotation");

		//https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
		navigator.mediaDevices.getUserMedia({video: true, audio: false}).then(function(stream) {
			video.srcObject = stream;
		}).catch(function(error) {
			console.log("%cVideo Error: " + error, 'color: red');
		});
	};

	function animate() {
		if (currentMethod === DO_POSITION) {
			updateTexture();
			repaint();
			requestAnimFrame(animate);
		}
	}

	function updateTexture() {
		gl.bindTexture(gl.TEXTURE_2D, cameraTexture);
		//gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

		// Firefox warning: Failed to hit GPU-copy fast-path. Falling back to CPU upload.
		// https://bugzilla.mozilla.org/show_bug.cgi?id=1246410
		// https://bugzilla.mozilla.org/show_bug.cgi?id=1322746
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
	}

	function setupAfterGettingVideoStream() {
		width = canvas.width = video.videoWidth;
		height = canvas.height = video.videoHeight;

		// mobile portrait 360×640
		// mobile landscape 640×360
		//alert(width+", "+height);
		w4 = width/4;
		h4 = height/4;
		w12 = w4/3;
		h12 = h4/3;

		cameraTexture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, cameraTexture);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

		// allocate readBuffer for reading pixels
		let arraySize = Math.ceil(w12 * h12 * 4);
		readBuffer = new Float32Array(arraySize);

		// hide loading message
		document.querySelector(".loading-container").classList.add("hidden");
		document.querySelector(".main").classList.remove("hidden");

		animate();

		sendPositionInterval = setInterval(sendPosition, 50);
	}

	function sendPosition() {
		if (dataToSend.length === 0) return;

		let sumMax = 0, sumX = 0, sumY = 0;
		for (let i = 0; i < dataToSend.length; i+=3) {
			sumMax += dataToSend[i];
			sumX += dataToSend[i+1];
			sumY += dataToSend[i+2];
		}
		let max = sumMax / (dataToSend.length / 3);
		let coordX = sumX / (dataToSend.length / 3);
		let coordY = sumY / (dataToSend.length / 3);
		// clear dataToSend
		dataToSend.length = 0;

		let request = new XMLHttpRequest();
		request.open("POST", "/ajax/marker");
		request.setRequestHeader("Content-Type", "application/json;charset=UTF-8");

		let obj = {
			type: "marker",
			time: new Date().getTime(),
			sequence: ++positionSequence,
			max: max,
			x: coordX,
			y: coordY
		};
		request.send(JSON.stringify(obj));
	}

	function doNothing() {
		// finish others
		Rotation.finish();
		clearInterval(sendPositionInterval);
		// set nothing
		currentMethod = DO_NOTHING;
		// send any possible remaining data
		sendPosition();
	}

	function doPosition() {
		// finish others
		Rotation.finish();

		// making sure that animation is not run multiple times
		if (currentMethod !== DO_POSITION) {
			currentMethod = DO_POSITION;
			// restart the sequence so the receiver can also restart the relative position
			positionSequence = 0;
			// start rendering again and set sending interval
			animate();
			sendPositionInterval = setInterval(sendPosition, 50);
		}
	}

	function doRotation() {
		currentMethod = DO_ROTATION;
		Rotation.start();
	}

	function windowSizeChanged() {
		if (window.innerHeight < window.innerWidth) {
			document.querySelector(".main").classList.remove("bottom");
			document.querySelector(".main").classList.add("right");
		} else {
			document.querySelector(".main").classList.remove("right");
			document.querySelector(".main").classList.add("bottom");
		}
	}

</script>

</head>
<body>
<div class="loading-container">
	<div class="loading">
		Loading, please wait...<br>
		Access to your camera is needed for this appplication to work.<br>
		You might be asked for giving a permissison to access it.
	</div>
</div>
<div class="main hidden">
	<div class="center">
		<canvas></canvas>
		<video src="" autoplay muted></video>
	</div>
	<div class="controls">
		<label id="nothing">
			<input type="radio" name="aa" checked> Do nothing
		</label><br>
		<label id="position">
			<input type="radio" name="aa"> Position
		</label><br>
		<label id="rotation">
			<input type="radio" name="aa"> Rotation
		</label>
	</div>
</div>
</body>
</html>
